const mysql = require('mysql2/promise');
const axios = require('axios');
const fs = require('fs');

// Database configuration
const dbConfig = {
  host: process.env.DB_HOST_NAME,
  user: process.env.DB_USER_NAME,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
};

interface SuperstarSite {
  id: number;
  domain: string;
  login: string;
  password: string;
  active: number;
}

interface WordPressPost {
  id: number;
  title: { rendered: string };
  date: string;
  link: string;
  slug: string;
  author: number;
}

interface SuperstarSubmission {
  id: number;
  superstar_site_id: number;
  wordpress_post_id: number;
  title: string;
  url: string;
}

async function getAllActiveSuperstarSites(): Promise<SuperstarSite[]> {
  const connection = await mysql.createConnection(dbConfig);
  try {
    const [rows] = await connection.query<any[]>(`
      SELECT id, domain, login, password, active 
      FROM superstar_sites 
      WHERE active = 1
    `);
    return rows;
  } finally {
    await connection.end();
  }
}

async function getSuperstarSubmissions(siteId: number): Promise<SuperstarSubmission[]> {
  const connection = await mysql.createConnection(dbConfig);
  try {
    const [rows] = await connection.query<any[]>(`
      SELECT id, superstar_site_id, wordpress_post_id, title, url 
      FROM superstar_site_submissions 
      WHERE superstar_site_id = ? AND deleted_at IS NULL
    `, [siteId]);
    return rows;
  } finally {
    await connection.end();
  }
}

async function getAllWordPressPosts(site: SuperstarSite, perPage = 100): Promise<WordPressPost[]> {
  let page = 1;
  let allPosts: WordPressPost[] = [];
  let hasMorePosts = true;
  
  // Add protocol if missing
  const domain = site.domain.startsWith('http') ? site.domain : `https://${site.domain}`;
  
  try {
    while (hasMorePosts) {
      console.log(`Fetching page ${page} of posts from ${domain}...`);
      const response = await axios.get(`${domain}/wp-json/wp/v2/posts`, {
        params: { 
          per_page: perPage,
          page: page,
          _fields: 'id,title,date,link,slug,author'
        },
        auth: {
          username: site.login,
          password: site.password,
        },
        timeout: 20000 // 20 second timeout
      });
      
      const posts: WordPressPost[] = response.data;
      if (posts.length === 0) {
        hasMorePosts = false;
      } else {
        allPosts = [...allPosts, ...posts];
        page++;
        
        // Check if we've reached the last page by examining headers
        const totalPages = parseInt(response.headers['x-wp-totalpages'], 10);
        if (page > totalPages) {
          hasMorePosts = false;
        }
      }
    }
    
    return allPosts;
  } catch (error: any) {
    console.error(`Error fetching posts from ${domain}:`, error.message);
    return [];
  }
}

async function importManualPost(
  siteId: number, 
  postId: number, 
  title: string, 
  link: string, 
  date: string
): Promise<boolean> {
  const connection = await mysql.createConnection(dbConfig);
  try {
    // Check if the necessary columns exist
    const [retroactiveColumns] = await connection.query(`
      SHOW COLUMNS FROM superstar_site_submissions LIKE 'retroactively_imported'
    `);
    
    // If the retroactively_imported column doesn't exist, add it
    const retroactiveColumnsArray = retroactiveColumns as any[];
    if (retroactiveColumnsArray.length === 0) {
      console.log('Adding retroactively_imported column to superstar_site_submissions table');
      await connection.query(`
        ALTER TABLE superstar_site_submissions 
        ADD COLUMN retroactively_imported TINYINT(1) DEFAULT 0
      `);
    }
    
    // Check for notes column
    const [notesColumns] = await connection.query(`
      SHOW COLUMNS FROM superstar_site_submissions LIKE 'notes'
    `);
    
    // If the notes column doesn't exist, add it
    const notesColumnsArray = notesColumns as any[];
    if (notesColumnsArray.length === 0) {
      console.log('Adding notes column to superstar_site_submissions table');
      await connection.query(`
        ALTER TABLE superstar_site_submissions 
        ADD COLUMN notes TEXT
      `);
    }
    
    // Insert the manual post into our superstar_site_submissions table
    await connection.query(`
      INSERT INTO superstar_site_submissions 
      (superstar_site_id, wordpress_post_id, title, url, created_at, updated_at, autogenerated, retroactively_imported, notes) 
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      siteId,
      postId,
      title,
      link,
      new Date(date),
      new Date(),
      0, // Set autogenerated to 0 since this was a manual post
      1, // Mark as retroactively imported
      `Retroactively imported by script on ${new Date().toISOString()}. This post existed on WordPress but was not in our tracking system.`
    ]);
    return true;
  } catch (error) {
    console.error(`Failed to import post ${postId} to database:`, error);
    return false;
  } finally {
    await connection.end();
  }
}

async function findManualPosts(shouldImport = false) {
  try {
    // 1. Get all active superstar sites
    console.log('Fetching all active superstar sites...');
    const sites = await getAllActiveSuperstarSites();
    console.log(`Found ${sites.length} active superstar sites.`);
    
    const results: any[] = [];
    let totalImported = 0;
    
    // 2. For each site, get its WordPress posts and compare with our submissions
    for (const site of sites) {
      try {
        console.log(`\nProcessing site: ${site.domain} (ID: ${site.id})`);
        
        // Get all submissions for this site
        const submissions = await getSuperstarSubmissions(site.id);
        console.log(`Found ${submissions.length} submissions in our database for this site.`);
        
        // Create a set of WordPress post IDs that we know about
        const knownPostIds = new Set(submissions.map(s => s.wordpress_post_id));
        
        // Get all posts from the WordPress site
        const wpPosts = await getAllWordPressPosts(site);
        console.log(`Found ${wpPosts.length} total posts on the WordPress site.`);
        
        // Find posts that aren't in our submissions
        const manualPosts = wpPosts.filter(post => !knownPostIds.has(post.id));
        console.log(`Found ${manualPosts.length} manual posts.`);
        
        let importedCount = 0;
        
        if (manualPosts.length > 0) {
          // Import posts if requested
          if (shouldImport) {
            console.log(`Importing ${manualPosts.length} manual posts to database...`);
            for (const post of manualPosts) {
              const success = await importManualPost(
                site.id,
                post.id,
                post.title.rendered,
                post.link,
                post.date
              );
              if (success) {
                importedCount++;
              }
            }
            console.log(`Successfully imported ${importedCount} posts.`);
            totalImported += importedCount;
          }
          
          results.push({
            site_id: site.id,
            domain: site.domain,
            manual_posts: manualPosts.map(post => ({
              post_id: post.id,
              title: post.title.rendered,
              date: post.date,
              link: post.link,
              slug: post.slug,
              author: post.author,
              imported: shouldImport ? true : undefined
            }))
          });
        }
      } catch (error) {
        console.error(`Error processing site ${site.domain}:`, error);
      }
    }
    
    // 3. Write results to a JSON file
    const timestamp = new Date().toISOString().replace(/:/g, '-');
    const action = shouldImport ? 'imported' : 'found';
    const outputPath = `./manual_posts_${action}_${timestamp}.json`;
    fs.writeFileSync(outputPath, JSON.stringify(results, null, 2));
    
    console.log(`\nComplete! Found manual posts on ${results.length} sites.`);
    if (shouldImport) {
      console.log(`Imported a total of ${totalImported} posts to the database.`);
    }
    console.log(`Results written to ${outputPath}`);
    
    // Also print a summary
    console.log('\nSummary:');
    results.forEach(site => {
      console.log(`${site.domain}: ${site.manual_posts.length} manual posts`);
    });
    
  } catch (error) {
    console.error('Script failed:', error);
  }
}

// Parse command line arguments
async function main() {
  const args = process.argv.slice(2);
  const shouldImport = args.includes('--import');
  const targetSite = args.find(arg => arg.startsWith('--site='))?.split('=')[1];
  
  console.log('=== Manual Posts Discovery Tool ===');
  if (shouldImport) {
    console.log('Running in IMPORT mode. Found posts will be imported to the database.');
  } else {
    console.log('Running in DISCOVERY mode. Posts will only be listed, not imported.');
    console.log('(Use --import flag to import posts to the database)');
  }
  
  if (targetSite) {
    console.log(`Filtering by site domain: ${targetSite}`);
  }
  
  // Filter sites if needed
  if (targetSite) {
    const allSites = await getAllActiveSuperstarSites();
    const filteredSites = allSites.filter(site => site.domain.includes(targetSite));
    
    if (filteredSites.length === 0) {
      console.error(`No active sites found matching ${targetSite}`);
      process.exit(1);
    }
    
    console.log(`Found ${filteredSites.length} matching sites. Processing these only.`);
    
    // Process only this site
    for (const site of filteredSites) {
      try {
        await processSite(site, shouldImport);
      } catch (error) {
        console.error(`Error processing site ${site.domain}:`, error);
      }
    }
  } else {
    // Process all sites
    await findManualPosts(shouldImport);
  }
}

// Process a single site
async function processSite(site: SuperstarSite, shouldImport = false) {
  try {
    console.log(`\nProcessing site: ${site.domain} (ID: ${site.id})`);
    
    // Get all submissions for this site
    const submissions = await getSuperstarSubmissions(site.id);
    console.log(`Found ${submissions.length} submissions in our database for this site.`);
    
    // Create a set of WordPress post IDs that we know about
    const knownPostIds = new Set(submissions.map(s => s.wordpress_post_id));
    
    // Get all posts from the WordPress site
    const wpPosts = await getAllWordPressPosts(site);
    console.log(`Found ${wpPosts.length} total posts on the WordPress site.`);
    
    // Find posts that aren't in our submissions
    const manualPosts = wpPosts.filter(post => !knownPostIds.has(post.id));
    console.log(`Found ${manualPosts.length} manual posts.`);
    
    let importedCount = 0;
    
    if (manualPosts.length > 0) {
      // Import posts if requested
      if (shouldImport) {
        console.log(`Importing ${manualPosts.length} manual posts to database...`);
        for (const post of manualPosts) {
          const success = await importManualPost(
            site.id,
            post.id,
            post.title.rendered,
            post.link,
            post.date
          );
          if (success) {
            importedCount++;
          }
        }
        console.log(`Successfully imported ${importedCount} posts.`);
      }
      
      // Write single site results to a JSON file
      const timestamp = new Date().toISOString().replace(/:/g, '-');
      const action = shouldImport ? 'imported' : 'found';
      const outputPath = `./${site.domain.replace(/[^a-z0-9]/gi, '_')}_${action}_${timestamp}.json`;
      
      const results = {
        site_id: site.id,
        domain: site.domain,
        manual_posts: manualPosts.map(post => ({
          post_id: post.id,
          title: post.title.rendered,
          date: post.date,
          link: post.link,
          slug: post.slug,
          author: post.author,
          imported: shouldImport ? true : undefined
        }))
      };
      
      fs.writeFileSync(outputPath, JSON.stringify(results, null, 2));
      console.log(`Results written to ${outputPath}`);
    }
    
    return { manualPosts, importedCount };
  } catch (error) {
    console.error(`Error processing site ${site.domain}:`, error);
    throw error;
  }
}

// Run the script
main().catch(error => {
  console.error('Script failed:', error);
  process.exit(1);
});