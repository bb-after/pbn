import mysql from 'mysql2/promise';
import { NextApiRequest, NextApiResponse } from 'next';

// Create a connection pool instead of individual connections
const pool = mysql.createPool({
  host: process.env.DB_HOST_NAME,
  user: process.env.DB_USER_NAME,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
  waitForConnections: true,
  connectionLimit: 10, // Maximum number of connections in the pool
  queueLimit: 0
});

// Simple in-memory cache implementation
interface CacheItem {
  data: any;
  timestamp: number;
}

const cache: Record<string, CacheItem> = {};
const CACHE_TTL = 60 * 1000; // Cache lifetime: 60 seconds

const superstarSitesHandler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { search = '', active = '1' } = req.query;

  // Create a cache key based on the query parameters
  const cacheKey = `sites_${search}_${active}`;

  // Check if we have a valid cache entry
  const now = Date.now();
  if (cache[cacheKey] && (now - cache[cacheKey].timestamp) < CACHE_TTL) {
    // Return data from cache
    console.log('Returning superstar sites from cache');
    return res.status(200).json(cache[cacheKey].data);
  }

  // Get a connection from the pool
  const connection = await pool.getConnection();

  try {
    // Optimized query using conditional aggregation and faster aggregation techniques
    const query = `
      SELECT 
        ss.id, 
        ss.domain, 
        ss.login,
        ss.active,
        ss.hosting_site,
        ss.custom_prompt,
        IFNULL(auto_counts.count, 0) AS autogenerated_count,
        IFNULL(manual_counts.count, 0) AS manual_count,
        IFNULL(author_counts.count, 0) AS author_count,
        IFNULL(topics.topic_list, '') AS topics
      FROM 
        superstar_sites ss
      -- Get autogenerated counts separately (more efficient than filtered JOIN)
      LEFT JOIN (
        SELECT 
          superstar_site_id, 
          COUNT(*) AS count 
        FROM 
          superstar_site_submissions 
        WHERE 
          autogenerated = 1 AND deleted_at IS NULL
        GROUP BY 
          superstar_site_id
      ) auto_counts ON ss.id = auto_counts.superstar_site_id
      
      -- Get manual counts separately
      LEFT JOIN (
        SELECT 
          superstar_site_id, 
          COUNT(*) AS count 
        FROM 
          superstar_site_submissions 
        WHERE 
          autogenerated = 0 AND deleted_at IS NULL
        GROUP BY 
          superstar_site_id
      ) manual_counts ON ss.id = manual_counts.superstar_site_id
      
      -- Get author counts separately
      LEFT JOIN (
        SELECT 
          superstar_site_id, 
          COUNT(*) AS count 
        FROM 
          superstar_authors 
        GROUP BY 
          superstar_site_id
      ) author_counts ON ss.id = author_counts.superstar_site_id
      
      -- Get topics with GROUP_CONCAT but limit length
      LEFT JOIN (
        SELECT 
          superstar_site_id, 
          GROUP_CONCAT(DISTINCT topic ORDER BY topic SEPARATOR ', ') AS topic_list 
        FROM 
          superstar_site_topics 
        GROUP BY 
          superstar_site_id
      ) topics ON ss.id = topics.superstar_site_id
      
      WHERE 
        ss.domain LIKE ? AND (ss.active = ? OR (ss.active IS NULL AND ? = 0))
      ORDER BY 
        ss.domain ASC
    `;
    
    const [rows] = await connection.query(query, [`%${search}%`, active === '1' ? 1 : 0, active === '1' ? 1 : 0]);  

    // Release the connection back to the pool (don't close it)
    connection.release();

    // Store the result in cache
    cache[cacheKey] = {
      data: rows,
      timestamp: Date.now()
    };

    // Send the data as a JSON response
    res.status(200).json(rows);
  } catch (error: any) {
    console.error(error);
    res.status(500).json({ error: 'Failed to fetch data', details: error.message });
    
    // Always release the connection back to the pool, even in case of error
    connection.release();
  }
};

export default superstarSitesHandler;
