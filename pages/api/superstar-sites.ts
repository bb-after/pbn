import mysql from 'mysql2/promise';
import { NextApiRequest, NextApiResponse } from 'next';

const dbConfig = {
  host: process.env.DB_HOST_NAME,
  user: process.env.DB_USER_NAME,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
};

export default async (req: NextApiRequest, res: NextApiResponse) => {
  // Create a MySQL connection
  const connection = await mysql.createConnection(dbConfig);

  try {
    const query = `
      SELECT 
        ss.id, 
        ss.domain, 
        SUM(CASE WHEN sss1.autogenerated = 1 THEN 1 ELSE 0 END) AS autogenerated_count,
        SUM(CASE WHEN sss2.autogenerated = 0 THEN 1 ELSE 0 END) AS manual_count,
        GROUP_CONCAT(DISTINCT sst.topic) AS topics
      FROM 
        superstar_sites ss
      LEFT JOIN 
        superstar_site_submissions sss1 ON ss.id = sss1.superstar_site_id AND sss1.autogenerated = 1
      LEFT JOIN 
        superstar_site_submissions sss2 ON ss.id = sss2.superstar_site_id AND sss2.autogenerated = 0
      LEFT JOIN 
        superstar_site_topics sst ON ss.id = sst.superstar_site_id
      WHERE 
        ss.active = 1
      GROUP BY 
        ss.id;
    `;
    
    const [rows] = await connection.query(query);  

    // Close the MySQL connection
    await connection.end();

    // Send the data as a JSON response
    res.status(200).json(rows);
  } catch (error: any) {
    console.error(error);
    res.status(500).json({ error: 'Failed to fetch data', details: error.message });
    
    // Close the MySQL connection in case of an error, but only if it's still open
    if (connection && connection.end) {
      await connection.end();
    }
  }
};
