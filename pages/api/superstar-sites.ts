import mysql from 'mysql2/promise';
import { NextApiRequest, NextApiResponse } from 'next';

const dbConfig = {
  host: process.env.DB_HOST_NAME,
  user: process.env.DB_USER_NAME,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
};

export default async (req: NextApiRequest, res: NextApiResponse) => {
  const { search = '', active = '1' } = req.query;

  // Create a MySQL connection
  const connection = await mysql.createConnection(dbConfig);

  try {
    // Construct the SQL query with optional search and active parameters
    const query = `
      SELECT 
        ss.id, 
        ss.domain, 
        ss.login,
        ss.active,
        ss.hosting_site,
        COALESCE(COUNT(sss1.id), 0) AS autogenerated_count,
        COALESCE(COUNT(sss2.id), 0) AS manual_count,
        (SELECT COUNT(*) FROM superstar_authors sa WHERE sa.superstar_site_id = ss.id) AS author_count,
        GROUP_CONCAT(DISTINCT sst.topic) AS topics
      FROM 
        superstar_sites ss
      LEFT JOIN 
        (SELECT superstar_site_id, id FROM superstar_site_submissions WHERE autogenerated = 1) sss1 ON ss.id = sss1.superstar_site_id
      LEFT JOIN 
        (SELECT superstar_site_id, id FROM superstar_site_submissions WHERE autogenerated = 0) sss2 ON ss.id = sss2.superstar_site_id
      LEFT JOIN 
        superstar_site_topics sst ON ss.id = sst.superstar_site_id
      WHERE 
        ss.domain LIKE ? AND (ss.active = ? OR (ss.active IS NULL AND ? = 0))
      GROUP BY 
        ss.id, ss.domain
      ORDER BY 
        ss.domain ASC
    `;
    
    const [rows] = await connection.query(query, [`%${search}%`, active === '1' ? 1 : 0, active === '1' ? 1 : 0]);  

    // Close the MySQL connection
    await connection.end();

    // Send the data as a JSON response
    res.status(200).json(rows);
  } catch (error: any) {
    console.error(error);
    res.status(500).json({ error: 'Failed to fetch data', details: error.message });
    
    // Close the MySQL connection in case of an error, but only if it's still open
    if (connection && connection.end) {
      await connection.end();
    }
  }
};
