import type { NextApiRequest, NextApiResponse } from 'next';
import mysql, { RowDataPacket } from 'mysql2/promise';
import { postToWordpress } from '../../utils/postToWordpress';
import { postToSlack } from '../../utils/postToSlack';
import { getOrCreateCategory } from 'utils/categoryUtils';

const dbConfig = {
  host: process.env.DB_HOST_NAME,
  user: process.env.DB_USER_NAME,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
};

const SLACK_CHANNEL = 'superstar-alerts';

interface SuperstarSite extends RowDataPacket {
  id: number;
  domain: string;
  hosting_site: string;
  login: string;
  password: string;
  autogenerated_count: number;
  manual_count: number;
  topics: string[];
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }


  const { siteId, title, content, tags, clientName, author, authorId, userToken } = req.body;

  if (!siteId || !content || !clientName) {
    return res.status(400).json({ message: 'Missing required fields' });
  }

  // Make sure tags exists and is properly formatted
  const formattedTags = tags ? (typeof tags === 'string' ? [tags] : tags) : ['uncategorized'];
  
  // Continue even without tags - we'll use the default category

  const connection = await mysql.createConnection(dbConfig);
  let site: SuperstarSite | null = null;
  const [rows] = await connection.query<SuperstarSite[]>('SELECT * FROM superstar_sites WHERE id = ?', [siteId]);
  site = rows[0];

  if (!site) {
    throw new Error('Site not found');
  }

  // Get a random author for this site if no specific author_id is provided
  let wpAuthorId: number | undefined;
  if (!author) {
    const [authors] = await connection.query(
      'SELECT wp_author_id FROM superstar_authors WHERE superstar_site_id = ? ORDER BY RAND() LIMIT 1',
      [siteId]
    );
    
    if (Array.isArray(authors) && authors.length > 0) {
      wpAuthorId = (authors[0] as any).wp_author_id;
    }
  } else {
    wpAuthorId = parseInt(author, 10);
  }

  console.log("site?", site);
  console.log("Using WordPress author ID:", wpAuthorId);

  try {
    // Don't encode the username in the auth object itself
    const auth = {
      username: site.login,
      password: site.hosting_site, // Use hosting_site (application password)
    };
    
    console.log(`Using auth credentials: ${site.login} (password hidden)`);
    

    // Ensure the category exists (and get its ID)
    // Use the first tag, or fallback to "uncategorized" if no tags
    const categoryName = formattedTags.length > 0 ? formattedTags[0] : 'uncategorized';
    const categoryId = await getOrCreateCategory(site.domain, categoryName, auth);
    
    // Convert wpAuthorId to string for the WordPress API
    const authorIdForWP = wpAuthorId ? String(wpAuthorId) : undefined;
    console.log(`Using author ID for WordPress: ${authorIdForWP || 'None (will use default)'}`);
    
    const response = await postToWordpress({
      title: title,
      content,
      domain: site.domain,
      auth,
      categoryId: categoryId,
    });

    console.log('Response from WordPress:', response);

    if (!response.title || !content || !response.link) {
      throw new Error('Response from WordPress contains undefined values');
    }

    // Get the superstar_author_id - either directly from authorId parameter or lookup by wp_author_id
    let superstarAuthorId: number | null = null;
    
    // If authorId was passed directly, use it
    if (authorId) {
      superstarAuthorId = parseInt(authorId, 10);
    } 
    // Otherwise if WordPress author ID was used, look up the corresponding superstar_author_id
    else if (wpAuthorId) {
      const [authorRows] = await connection.query(
        'SELECT id FROM superstar_authors WHERE superstar_site_id = ? AND wp_author_id = ?',
        [siteId, wpAuthorId]
      );
      
      if (Array.isArray(authorRows) && authorRows.length > 0) {
        superstarAuthorId = (authorRows[0] as any).id;
      }
    }
    
    await connection.execute(
      'INSERT INTO superstar_site_submissions (superstar_site_id, title, content, client_name, submission_response, user_token, autogenerated, superstar_author_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
      [siteId, response.title.rendered, content, clientName, response.link, userToken, 0, superstarAuthorId]
    );

    await postToSlack(`Successfully posted content to WordPress for site ${site.domain}.`, SLACK_CHANNEL);

    res.status(200).json({ message: 'Content posted successfully' });
  } catch (error: any) {
    const errorMessage = site
      ? `Failed to post content to WordPress for site ${site.domain}: ${error.message} using auth ${site.login}`
      : `Failed to post content to WordPress: ${error.message}`;

    await postToSlack(errorMessage, SLACK_CHANNEL);
    console.error('Error posting content to WordPress:', error);
    res.status(500).json({ message: errorMessage, stack: error.stack });
  } finally {
    await connection.end();
  }
}
