import type { NextApiRequest, NextApiResponse } from 'next';
import { RowDataPacket } from 'mysql2/promise';
import { postToWordpress } from '../../utils/postToWordpress';
import { postToSlack } from '../../utils/postToSlack';
import { generateSuperStarContent } from '../../utils/generateSuperStarContent';
import { getOrCreateCategory } from 'utils/categoryUtils';
import axios from 'axios';
import { query, transaction, getPool } from 'lib/db';

// This function can run for a maximum of 5 minutes (max on pro plan)
export const config = {
  maxDuration: 300,
};

const SLACK_CHANNEL = 'superstar-alerts';
const BATCH_SIZE = 10; // Process 10 sites at a time
const CONTENT_COOLDOWN_HOURS = 6; // Don't generate content for the same site within 6 hours

interface SuperstarSite extends RowDataPacket {
  id: number;
  domain: string;
  hosting_site: string;
  login: string;
  password: string;
  autogenerated_count: number;
  manual_count: number;
  topics: string[];
  custom_prompt?: string;
  last_submission?: Date;
}

interface SuperstarSiteTopic extends RowDataPacket {
  topic: string;
}

/**
 * Check if a WordPress site is accessible and responsive before generating content
 * This prevents wasting API credits on unreachable sites
 */
async function checkWordPressSiteHealth(
  domain: string,
  auth: { username: string; password: string }
): Promise<{ healthy: boolean; error?: string }> {
  try {
    // Ensure domain has protocol
    const siteUrl = domain.startsWith('http') ? domain : `https://${domain}`;

    // Try to access the WordPress REST API posts endpoint
    const testUrl = `${siteUrl}/wp-json/wp/v2/posts?per_page=1`;

    console.log(`Health checking WordPress site: ${testUrl}`);

    const response = await axios.get(testUrl, {
      auth: {
        username: auth.username,
        password: auth.password,
      },
      timeout: 10000, // 10 second timeout
      validateStatus: status => status < 500, // Don't throw on 4xx errors, only 5xx
    });

    if (response.status >= 200 && response.status < 300) {
      console.log(`âœ… Site ${domain} is healthy (${response.status})`);
      return { healthy: true };
    } else if (response.status === 401) {
      console.log(`âŒ Site ${domain} authentication failed (${response.status})`);
      return { healthy: false, error: `Authentication failed (401) - Invalid credentials` };
    } else if (response.status === 404) {
      console.log(`âŒ Site ${domain} not found (${response.status})`);
      return { healthy: false, error: `Site not found (404) - WordPress REST API not accessible` };
    } else {
      console.log(`âš ï¸ Site ${domain} returned status ${response.status}`);
      return { healthy: false, error: `Site returned status ${response.status}` };
    }
  } catch (error: any) {
    console.log(`âŒ Health check failed for ${domain}:`, error.message);

    if (error.code === 'ENOTFOUND') {
      return { healthy: false, error: 'Domain not found (DNS resolution failed)' };
    } else if (error.code === 'ECONNREFUSED') {
      return { healthy: false, error: 'Connection refused (server not responding)' };
    } else if (error.code === 'ETIMEDOUT') {
      return { healthy: false, error: 'Connection timeout (server too slow to respond)' };
    } else {
      return { healthy: false, error: `Connection error: ${error.message}` };
    }
  }
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  const connection = await getPool().getConnection();
  try {
    console.log(`Fetching up to ${BATCH_SIZE} eligible superstar sites...`);

    // Get sites that haven't had content generated in the last X hours
    // Prioritize sites that have never had content or haven't had content in the longest time
    const [sites]: [SuperstarSite[], any] = await connection.query(
      `
      SELECT s.*, 
             MAX(sub.created) as last_submission
      FROM superstar_sites s
      LEFT JOIN superstar_site_submissions sub ON s.id = sub.superstar_site_id
      WHERE s.active = 1
      GROUP BY s.id
      HAVING (
        last_submission IS NULL 
        OR last_submission < DATE_SUB(NOW(), INTERVAL ? HOUR)
      )
      ORDER BY RAND()
      LIMIT ?
    `,
      [CONTENT_COOLDOWN_HOURS, BATCH_SIZE]
    );

    console.log(`Found ${sites.length} eligible sites (out of max ${BATCH_SIZE})`);

    if (sites.length === 0) {
      console.log('No sites eligible for content generation at this time');
      return res.status(200).json({
        message: 'No sites eligible for content generation',
        reason: `All active sites have had content generated within the last ${CONTENT_COOLDOWN_HOURS} hours`,
      });
    }

    const results = {
      processed: 0,
      successful: 0,
      failed: 0,
      skipped: 0, // Add counter for skipped unhealthy sites
      sites: [] as any[],
    };

    const tasks = sites.map(async site => {
      console.log(
        `Processing site: ${site.domain} (last content: ${site.last_submission || 'never'})`
      );
      results.processed++;

      const siteResult = {
        domain: site.domain,
        status: 'processing',
        error: null as string | null,
        contentTitle: null as string | null,
        wordpressUrl: null as string | null,
        healthCheck: null as string | null,
      };

      try {
        const auth = { username: site.login, password: site.password };

        // ðŸ” HEALTH CHECK: Verify site is accessible BEFORE generating expensive content
        console.log(`âš•ï¸ Health checking site ${site.domain} before content generation...`);
        const healthResult = await checkWordPressSiteHealth(site.domain, auth);

        if (!healthResult.healthy) {
          console.log(
            `âŒ Skipping content generation for unhealthy site ${site.domain}: ${healthResult.error}`
          );
          siteResult.status = 'skipped';
          siteResult.error = `Site health check failed: ${healthResult.error}`;
          siteResult.healthCheck = 'failed';
          results.skipped++;
          results.failed++; // Also count as failed for backwards compatibility

          // Send specific Slack notification for unhealthy sites
          await postToSlack(
            `âš•ï¸âŒ Skipped content generation for unhealthy site ${site.domain}: ${healthResult.error}`,
            SLACK_CHANNEL
          );

          return siteResult;
        }

        siteResult.healthCheck = 'passed';
        console.log(
          `âœ… Site ${site.domain} passed health check, proceeding with content generation...`
        );

        const [topics]: [SuperstarSiteTopic[], any] = await connection.query(
          'SELECT topic FROM superstar_site_topics WHERE superstar_site_id = ?',
          [site.id]
        );

        if (topics.length === 0) {
          console.log(`No topics found for site ID ${site.id}`);
          siteResult.status = 'failed';
          siteResult.error = 'No topics configured';
          results.failed++;
          return siteResult;
        }

        const randomTopic = topics[Math.floor(Math.random() * topics.length)].topic;
        console.log(`Selected topic: ${randomTopic}`);

        const { title, body: content } = await generateSuperStarContent(randomTopic, site);
        console.log(`Generated content for topic "${randomTopic}": ${title}`);
        siteResult.contentTitle = title;

        const categoryId = await getOrCreateCategory(site.domain, randomTopic, auth);

        console.log(`Posting content to WordPress for site ${site.domain}`);
        const response = await postToWordpress({
          title,
          content,
          domain: site.domain,
          auth,
          categoryId: categoryId,
        });

        console.log(`Posted content to WordPress: ${response.link}`);
        siteResult.wordpressUrl = response.link;
        siteResult.status = 'success';

        // Insert into database with wordpress_post_id
        const wordpressPostId = response.id;
        await connection.execute(
          'INSERT INTO superstar_site_submissions (superstar_site_id, title, content, submission_response, autogenerated, wordpress_post_id) VALUES (?, ?, ?, ?, ?, ?)',
          [site.id, response.title.rendered, content, response.link, 1, wordpressPostId]
        );

        await postToSlack(
          `âœ… Successfully posted content to WordPress for site ${site.domain} on topic "${randomTopic}".`,
          SLACK_CHANNEL
        );

        results.successful++;
      } catch (error: any) {
        const errorMessage = `Failed to post content to WordPress for site ${site.domain}: ${error.message}`;
        siteResult.status = 'failed';
        siteResult.error = error.message;
        results.failed++;

        await postToSlack(`âŒ ${errorMessage}`, SLACK_CHANNEL);
        console.error('Error posting content to WordPress:', error);
      }

      results.sites.push(siteResult);
      return siteResult;
    });

    await Promise.all(tasks);

    console.log(`Batch processing complete: ${results.successful}/${results.processed} successful`);

    // Send summary to Slack if there were any results
    if (results.processed > 0) {
      const actualFailures = results.failed - results.skipped;
      await postToSlack(
        `ðŸš€ Batch content generation complete:\n` +
          `â€¢ Processed: ${results.processed} sites\n` +
          `â€¢ Successful: ${results.successful}\n` +
          `â€¢ Failed: ${actualFailures}\n` +
          `â€¢ Skipped (unhealthy): ${results.skipped}\n` +
          `â€¢ Credits saved by skipping unhealthy sites ðŸ’°\n` +
          `â€¢ Next batch available in ${CONTENT_COOLDOWN_HOURS} hours`,
        SLACK_CHANNEL
      );
    }

    res.status(200).json({
      message: 'Batch content generation completed',
      ...results,
      summary: {
        healthChecksEnabled: true,
        creditsSavedBySkipping: results.skipped,
        actualFailures: results.failed - results.skipped,
      },
      config: {
        batchSize: BATCH_SIZE,
        cooldownHours: CONTENT_COOLDOWN_HOURS,
      },
    });
  } catch (error: any) {
    console.error('Error in batch content generation:', error);
    await postToSlack(
      `ðŸ’¥ Critical error in superstar content generation: ${error.message}`,
      SLACK_CHANNEL
    );
    res.status(500).json({
      message: 'Failed to generate content',
      details: error.message,
    });
  } finally {
    console.log('Releasing database connection.');
    connection.release(); // Release the connection back to the pool
  }
}
