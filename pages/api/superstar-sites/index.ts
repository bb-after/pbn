import { query, transaction, getPool } from 'lib/db';
import { NextApiRequest, NextApiResponse } from 'next';

// Use centralized connection pool
const pool = getPool();
// Simple in-memory cache implementation
interface CacheItem {
  data: any;
  timestamp: number;
}

const cache: Record<string, CacheItem> = {};
const CACHE_TTL = 60 * 1000; // Cache lifetime: 60 seconds

const superstarSitesHandler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { search = '', active = '1' } = req.query;

  // Create a cache key based on the query parameters
  const cacheKey = `sites_${search}_${active}`;

  // Check if we have a valid cache entry
  const now = Date.now();
  if (cache[cacheKey] && now - cache[cacheKey].timestamp < CACHE_TTL) {
    // Return data from cache
    console.log('Returning superstar sites from cache');
    return res.status(200).json(cache[cacheKey].data);
  }

  // Get a connection from the pool
  const connection = await pool.getConnection();

  try {
    // Optimized query using conditional aggregation and faster aggregation techniques
    const query = `
      SELECT 
        ss.id, 
        ss.domain, 
        ss.login,
        ss.active,
        ss.hosting_site,
        ss.custom_prompt,
        IFNULL(auto_counts.count, 0) AS autogenerated_count,
        IFNULL(manual_counts.count, 0) AS manual_count,
        IFNULL(author_counts.count, 0) AS author_count,
        IFNULL(topics.topic_list, '') AS topics,
        client_counts.client_post_data
      FROM 
        superstar_sites ss
      -- Get autogenerated counts separately (more efficient than filtered JOIN)
      LEFT JOIN (
        SELECT 
          superstar_site_id, 
          COUNT(*) AS count 
        FROM 
          superstar_site_submissions 
        WHERE 
          autogenerated = 1 AND deleted_at IS NULL
        GROUP BY 
          superstar_site_id
      ) auto_counts ON ss.id = auto_counts.superstar_site_id
      
      -- Get manual counts separately
      LEFT JOIN (
        SELECT 
          superstar_site_id, 
          COUNT(*) AS count 
        FROM 
          superstar_site_submissions 
        WHERE 
          autogenerated = 0 AND deleted_at IS NULL
        GROUP BY 
          superstar_site_id
      ) manual_counts ON ss.id = manual_counts.superstar_site_id
      
      -- Get author counts separately
      LEFT JOIN (
        SELECT 
          superstar_site_id, 
          COUNT(*) AS count 
        FROM 
          superstar_authors 
        GROUP BY 
          superstar_site_id
      ) author_counts ON ss.id = author_counts.superstar_site_id
      
      -- Get topics with GROUP_CONCAT but limit length
      LEFT JOIN (
        SELECT 
          superstar_site_id, 
          GROUP_CONCAT(DISTINCT topic ORDER BY topic SEPARATOR ', ') AS topic_list 
        FROM 
          superstar_site_topics 
        GROUP BY 
          superstar_site_id
      ) topics ON ss.id = topics.superstar_site_id
      
      -- Get client post counts with client information
      LEFT JOIN (
        SELECT 
          counts.superstar_site_id,
          GROUP_CONCAT(
            CONCAT(
              counts.client_id, ':', 
              counts.client_name, ':', 
              counts.post_count
            ) SEPARATOR '|'
          ) as client_post_data
        FROM (
          SELECT 
            sss.superstar_site_id,
            sss.client_id,
            c.client_name,
            COUNT(*) as post_count
          FROM 
            superstar_site_submissions sss
          JOIN
            clients c ON sss.client_id = c.client_id
          WHERE 
            sss.deleted_at IS NULL AND
            sss.client_id IS NOT NULL
          GROUP BY 
            sss.superstar_site_id, sss.client_id, c.client_name
        ) counts
        GROUP BY 
          counts.superstar_site_id
      ) client_counts ON ss.id = client_counts.superstar_site_id
      
      WHERE 
        ss.domain LIKE ? AND (ss.active = ? OR (ss.active IS NULL AND ? = 0))
      ORDER BY 
        ss.domain ASC
    `;

    const [rows] = await connection.query(query, [
      `%${search}%`,
      active === '1' ? 1 : 0,
      active === '1' ? 1 : 0,
    ]);

    // Release the connection back to the pool (don't close it)
    connection.release();

    // Store the result in cache
    cache[cacheKey] = {
      data: rows,
      timestamp: Date.now(),
    };

    // Send the data as a JSON response
    res.status(200).json(rows);
  } catch (error: any) {
    console.error(error);
    res.status(500).json({ error: 'Failed to fetch data', details: error.message });

    // Always release the connection back to the pool, even in case of error
    connection.release();
  }
};

export default superstarSitesHandler;
