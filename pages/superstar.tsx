import { useState, useEffect } from "react";
import {
  Button,
  TextField,
  CircularProgress,
  MenuItem,
  Select,
  InputLabel,
  FormControl,
  OutlinedInput,
  Box,
  Typography,
  Autocomplete,
  Chip,
} from "@mui/material";
import LayoutContainer from "../components/LayoutContainer";
import StyledHeader from "../components/StyledHeader";
import axios from "axios";
import dynamic from "next/dynamic";
import { formatSuperstarContent } from "utils/formatSuperstarContent";
import { colors } from "../utils/colors";
import router from "next/router";
import useValidateUserToken from "hooks/useValidateUserToken";

const ReactQuill = dynamic(() => import("react-quill"), { ssr: false });
import "react-quill/dist/quill.snow.css"; // Import styles for ReactQuill

interface SuperstarSite {
  id: number;
  domain: string;
  hosting_site: string;
  autogenerated_count: number;
  manual_count: number;
  topics: string[] | string;
}

const HomePage = () => {
  const [topic, setTopic] = useState<string[]>([]);
  const [title, setTitle] = useState("");
  const [loading, setLoading] = useState(false);
  const [content, setContent] = useState("");
  const [editableContent, setEditableContent] = useState("");
  const [sites, setSites] = useState<SuperstarSite[]>([]);
  const [selectedSite, setSelectedSite] = useState("");
  const [categories, setCategories] = useState("");
  const [tags, setTags] = useState<string[]>([]);
  const [author, setAuthor] = useState("");
  const [clientName, setClientName] = useState("Superstar AI"); // Default client name
  const [authors, setAuthors] = useState<
    {
      id: number;
      author_name: string;
      wp_author_id: number;
      author_avatar?: string;
    }[]
  >([]);
  const [isLoadingAuthors, setIsLoadingAuthors] = useState(false);
  const [isLoadingSites, setIsLoadingSites] = useState(false);
  const { isValidUser } = useValidateUserToken();

  useEffect(() => {
    const fetchSites = async () => {
      setIsLoadingSites(true);
      try {
        const response = await axios.get<SuperstarSite[]>(
          "/api/superstar-sites"
        );
        const parsedData = response.data.map((site) => ({
          ...site,
        }));
        setSites(parsedData);
      } catch (error) {
        console.error("Error fetching sites:", error);
      } finally {
        setIsLoadingSites(false);
      }
    };

    fetchSites();
  }, []);

  useEffect(() => {
    if (selectedSite) {
      const site = sites.find((s) => s.id === Number(selectedSite));
      if (site) {
        if (Array.isArray(site.topics)) {
          setTopic(site.topics);
        } else if (typeof site.topics === "string") {
          // Split by commas and trim whitespace, preserving multi-word categories
          setTopic(
            site.topics
              .split(",")
              .map((t) => t.trim())
              .filter((t) => t)
          );
        } else {
          setTopic([]);
        }

        // Reset author when site changes
        setAuthor("");

        // Fetch authors for this site
        fetchAuthorsForSite(selectedSite);
      }
    }
  }, [selectedSite, sites]);

  // Function to fetch authors for a selected site
  const fetchAuthorsForSite = async (siteId: string) => {
    if (!siteId) return;

    setIsLoadingAuthors(true);
    try {
      const response = await axios.get(
        `/api/superstar-authors/site?siteId=${siteId}`
      );
      setAuthors(response.data.authors || []);
    } catch (error) {
      console.error("Error fetching authors for site:", error);
      setAuthors([]);
    } finally {
      setIsLoadingAuthors(false);
    }
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    setLoading(true);
    const formattedTopics = topic.map((t) => encodeURIComponent(t)).join(",");
    const siteId = selectedSite;
    try {
      const response = await axios.get(
        `/api/generateContent?topic=${encodeURIComponent(
          formattedTopics
        )}&siteId=` + siteId
      );
      const { title, body, topic } = response.data;
      setTitle(title);
      setContent(body);
      setEditableContent(body);
      setLoading(false);
      setTags(topic);
    } catch (error: any) {
      console.error("Error generating content:", error);
      alert("There was an error generating content:" + error.message);
      setLoading(false);
    }
  };

  const handlePost = async () => {
    try {
      // Get the WordPress author ID if an author is selected
      let authorId;
      if (author) {
        const selectedAuthor = authors.find((a) => a.id.toString() === author);
        authorId = selectedAuthor?.wp_author_id;
      }

      // Handle tags safely - convert to comma-separated string if present, otherwise send empty string
      const formattedTags = tags && tags.length > 0 ? tags.join(", ") : "";

      const postContent = {
        siteId: selectedSite,
        title,
        content: editableContent,
        tags: formattedTags,
        clientName, // Include the client name
        author: authorId, // Send the WordPress author ID, not our internal ID
        authorId: author, // Also send our internal author ID for database references
      };

      await axios.post("/api/postSuperstarContentToWordpress", postContent);
      alert("Content posted successfully!");
      router.push("/superstar-site-submissions");
    } catch (error) {
      console.error("Error posting content:", error);
      alert("Failed to post content.");
    }
  };

  if (!isValidUser) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        height="100vh"
      >
        <Typography variant="h6">
          Unauthorized access. Please log in.
        </Typography>
      </Box>
    );
  }

  return (
    <LayoutContainer>
      <StyledHeader />
      <h1>Superstar Generator</h1>
      <FormControl fullWidth variant="outlined" margin="normal">
        <Autocomplete
          id="site-select"
          options={sites}
          getOptionLabel={(option) => option.domain}
          value={
            sites.find((site) => site.id.toString() === selectedSite) || null
          }
          onChange={(_, newValue) =>
            setSelectedSite(newValue ? newValue.id.toString() : "")
          }
          loading={isLoadingSites}
          renderInput={(params) => (
            <TextField 
              {...params} 
              label="Select Site" 
              variant="outlined"
              InputProps={{
                ...params.InputProps,
                endAdornment: (
                  <>
                    {isLoadingSites ? <CircularProgress color="inherit" size={20} /> : null}
                    {params.InputProps.endAdornment}
                  </>
                ),
              }}
            />
          )}
          renderOption={(props, option) => (
            <li {...props}>
              <Typography noWrap>{option.domain}</Typography>
            </li>
          )}
        />
      </FormControl>

      <Autocomplete
        multiple
        freeSolo
        options={[]}
        value={topic}
        onChange={(_, newValue) => setTopic(newValue)}
        renderTags={(value, getTagProps) =>
          value.map((option, index) => {
            const { key, ...rest } = getTagProps({ index });
            return (
              <Chip
                key={key}
                variant="filled"
                label={option}
                {...rest}
                sx={{
                  backgroundColor: colors[index % colors.length],
                  color: "#fff",
                  "&:hover": {
                    backgroundColor: colors[index % colors.length],
                    opacity: 0.9,
                  },
                }}
              />
            );
          })
        }
        renderInput={(params) => (
          <TextField
            {...params}
            variant="outlined"
            label="Categories"
            placeholder="Add categories"
            fullWidth
            margin="normal"
          />
        )}
      />

      <form onSubmit={handleSubmit}>
        <Button
          type="submit"
          variant="contained"
          color="primary"
          disabled={loading}
          style={{ marginTop: "16px" }}
        >
          {loading ? <CircularProgress size={24} /> : "Generate Content"}
        </Button>
      </form>
      {content && (
        <div style={{ marginTop: "16px" }}>
          <TextField
            variant="outlined"
            fullWidth
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            placeholder="Enter article title"
            margin="normal"
            label="Title"
          />
          <ReactQuill value={editableContent} onChange={setEditableContent} />
          <Autocomplete
            multiple
            freeSolo
            options={[]}
            value={tags}
            onChange={(_, newValue) => setTags(newValue)}
            renderTags={(value, getTagProps) =>
              value.map((option, index) => {
                const { key, ...rest } = getTagProps({ index });
                return (
                  <Chip
                    key={key}
                    variant="filled"
                    label={option}
                    {...rest}
                    sx={{
                      backgroundColor: colors[index % colors.length],
                      color: "#fff",
                      "&:hover": {
                        backgroundColor: colors[index % colors.length],
                        opacity: 0.9,
                      },
                    }}
                  />
                );
              })
            }
            renderInput={(params) => (
              <TextField
                {...params}
                variant="outlined"
                label="Tags (Optional)"
                placeholder="Add tags"
                fullWidth
                margin="normal"
              />
            )}
          />

          <TextField
            variant="outlined"
            fullWidth
            value={clientName}
            onChange={(e) => setClientName(e.target.value)}
            placeholder="Client Name"
            margin="normal"
            label="Client Name"
            required
          />

          {/* Author dropdown */}
          <FormControl fullWidth variant="outlined" margin="normal">
            <InputLabel id="author-select-label">
              Post Author (Optional)
            </InputLabel>
            <Select
              labelId="author-select-label"
              value={author}
              onChange={(e) => setAuthor(e.target.value as string)}
              label="Post Author (Optional)"
              disabled={isLoadingAuthors || authors.length === 0}
            >
              <MenuItem value="">
                <em>Default Author</em>
              </MenuItem>
              {authors.map((author) => (
                <MenuItem key={author.id} value={author.id.toString()}>
                  <Box display="flex" alignItems="center">
                    {author.author_avatar && (
                      <Box
                        component="img"
                        src={author.author_avatar}
                        alt={author.author_name}
                        sx={{
                          width: 24,
                          height: 24,
                          borderRadius: "50%",
                          marginRight: 1,
                        }}
                      />
                    )}
                    {author.author_name}
                  </Box>
                </MenuItem>
              ))}
            </Select>
            {authors.length === 0 && !isLoadingAuthors && selectedSite && (
              <Typography
                variant="caption"
                color="text.secondary"
                sx={{ mt: 1 }}
              >
                No authors found for this site.{" "}
                <a
                  href={`/superstar-sites/${selectedSite}/manage-authors`}
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  Manage Authors
                </a>
              </Typography>
            )}
          </FormControl>
        </div>
      )}
      <Button
        variant="contained"
        color="secondary"
        onClick={handlePost}
        disabled={!selectedSite || !title || !editableContent}
        style={{ marginTop: "16px" }}
      >
        Post to WordPress
      </Button>
    </LayoutContainer>
  );
};

export default HomePage;
